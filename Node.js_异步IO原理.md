#异步I/O
- 起源，前段工程师对于异步编程是比较熟悉的，在WEB2.0的浪潮中，它伴随这AJAX的第一个A席卷了WEB。向更深一步探究的话，异步存在于操作系统的底层，通过信号量
消息等方式得到广泛的应用。但是在高级编程语言中，它并没有得到广泛的应用，因为与程序员的正常思维出入太大。
- PHP语言的设计就屏蔽了异步，这样做的优点是符合程序员正常的业务逻辑，缺点在小规模站点中基本不存在，但是在复杂一些的网络应用中，会导致无法更好地并发。
##1.1为什么要选择异步
- 考虑到用户体验，在WEB2.0发展起来以后，用户的请求资源可能来自若干不同的URL，假设来自两个不同的位置，响应时间分别为M和N的话，同步处理响应时间为M+N，异步则为MAX(M,N)
- 考虑到资源分配，单线程同步编程模型会因为阻塞IO导致硬件资源得不到更优的使用，多线程编程模型也存在编程中的死锁、状态同步等问题。Node较好的在两者之间给出了解决方案，利用异步IO，同时让单线程原理阻塞。
##1.2一些需要搞清楚的名词
- 异步和同步，同步和异步是针对进程的业务流程而言，拿进程中读取文件这个IO为例，对于同步，一个读文件的命令发出后，要等到返回读取结果，然后才能继续往下执行。而异步则可以同时发出若干个读文件的命令，而不用等待上一个读文件的结果。
- 阻塞与非阻塞，操作系统对于IO只有两种处理方式，阻塞与非阻塞，前者CPU需要等待IO处理结果，而后者不需要，释放了CPU在阻塞IO模式下的资源消耗。
- 存在的问题，阻塞和同步毫无疑问对CPU的处理能力造成了极大的浪费，而异步和非阻塞也存在问题，非阻塞的话因为无法判断IO是否完成，所以需要重复调用IO操作来确认是否完成，这种操作成为轮询。
- 回调和事件。
##1.3异步IO实现现状
- 最理想的非阻塞异步IO，应该是由应用程序发起非阻塞调用，无需通过遍历或者事件等方式唤醒，直接处理下一个任务，待IO完成后通过信号或者回调将数据传递给应用程序。
- 现实实现起来仍较理想状态有较大差异，具体见P55。
##1.4Node中异步IO的实施
- 第一部分，调用C++模块发起异步调用，Node封装了libuv来进行操作系统平台的判断，首先它会将一个文件Open请求封装成为一个对象，然后通过libuv进行底层C函数调用，此时JS立即返回，第一阶段结束；
- 第二部分，回调通知，在Node主进程的事件循环中，会启动一个观察者，对线程池中是否存在已执行完毕的线程进行判断，每一次循环TICK都会返回当前执行完毕的线程，在NODE主循环中调取这些线程对应的回调函数。
##1.5小结
- 以事件循环作为异步实现的核心，由事件循环、观察者、请求对象、IO线程池共同构成了Node异步IO模型的基本框架。
